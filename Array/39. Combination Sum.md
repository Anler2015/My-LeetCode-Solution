dfs实现， 倒是很多重复的运算， 超时
```
class Solution:
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        if not candidates or target == 0:
            return []

        reslist = []
        path = []
        self.dfs(candidates,target,reslist,path)

        return reslist
        

    def dfs(self,candidates,target,reslist,path):
        if target == 0:

            if path not in reslist:
                reslist.append(path[:])
            return
        if target < 0:
            return
        if len(candidates) == 0:
            return

        for i in range(1,len(candidates)):
            self.dfs(candidates[i:],target,reslist,path)
        value = candidates[0]
        path.append(value)
        for i in range(len(candidates)):
            self.dfs(candidates[i:],target-value,reslist,path)
        path.pop()


```
